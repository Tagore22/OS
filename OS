1강
 - 컴퓨터를 단순히 미지의 대상에서 분석의 대상으로 인식하기 위해 컴퓨터 구조와 OS에 대해 알아야 한다
 - 문법에 맞는 소스 코드를 컴퓨터에 입력만 하는 개발자를 넘어 컴퓨터를 내려다보며 문제를 해결할 수 있는
 개발자를 지향해야 한다
 - 컴퓨터의 성능, 용량, 비용에 대해 알아야 한다

2강
 컴퓨터 구조의 큰 그림

컴퓨터가 이해하는 두 가지 정보
1. 데이터
- 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
- 컴퓨터와 주고 받는 내부에 저장된 정보를 데이터라 통칭함
- 0과 1로 숫자와 문자를 표현하는 방법
2. 명령어
- 컴퓨터는 결국 명령어를 처리하는 기계
- 컴퓨터를 실질적으로 움직이는 정보
- 데이터는 명령어를 위한 일종의 재료
- 명령어의 생김새와 동작 방식

컴퓨터의 4가지 핵심 부품
1. CPU
- 산술논리연산장치(계산기)인 ALU, CPU내의 저장을 위한 레지스터, 제어 신호를 내보내고 명령어를 해석하는
제어장치 3개로 구분할 수 있다
- 메모리에 저장된 값을 읽어 들이고, 해석하고, 실행하는 장치다
2. 메모리
- 현재 실행되는 프로그램(프로세스)의 명령어와 데이터를 저장하는 부품(RAM)
- 휘발성의 RAM과 비휘발성의 ROM으로 나뉘며 RAM에는 하드디스크의 저장된 데이터를 CPU에서 사용하기 위해
저장하고 ROM에는 부팅시스템 같은 읽기만 하는 데이터가 미리 저장되어 있다
- 프로그램이 실행되기 위해서는 메모리에 저장되어 있어야 한다
- 메모리는 실행되는 프로그램의 명령어와 데이터를 저장한다
- 메모리에 저장된 값의 위치는 주소로 알 수 있다
3. 보조기억장치
- 휘발성 있는 RAM을 대비하여 비휘발성의 보조기억장치가 존재한다
- 하드디스크, SSD 등이 해당함
4. 입출력장치
- 키보드, 모니터, 프린트 등이 해당한다
5. 메인보드
- 메인보드에 연결된 부품은 버스를 통해 정보를 주고 받음
- 버스는 컴퓨터의 부품끼리 정보를 주고 받는 일종의 통로
- 다양한 종류의 버스가 있으나 핵심 부품을 연결하는 버스는 시스템 버스

시스템 버스의 내부 구성
1. 주소 버스
- 주소를 주고 받는 통로
2. 데이터 버스
- 명령어와 데이터를 주고 받는 버스
3. 제어 버스
- 제어 신호를 주고 받는 버스
- 읽기와 쓰기 모두 3가지 버스를 전부 사용한다
- 읽을때에는 읽는 신호, 몇번지 값을 읽는지에 대해 제어 버스와 주소 버스를 사용하고 해당 데이터를 읽어들일때
데이터 버스를 사용한다
- 쓸때에는 쓰는 신호, 몇번지에 쓰는지, 쓸값을 이동시키기 위해 제어 버스, 주소 버스, 데이터 버스를 사용한다

3강
 컴퓨터의 4가지 핵심 부품 직접 보기로 대체

4강
 0과 1로 숫자를 표현하는 방법
정보 단위
1. 비트
- 비트란 0과 1을 표현하는 가장 작은 정보 단위를 뜻한다
- n비트로 2의 n제곱가지의 정보 표현 가능
- 프로그램은 많은 비트로 이루어져 있음
- 다만 평소에 800만 비트라고 표현하지 않고 바이트, 킬로바이트, 메가바이트, 기가바이트, 테라바이트 등으로
표현함
- 1바이트 == 8비트
- 1킬로바이트 == 1000바이트
- 1메가바이트 == 1000킬로바이트
- 1기가바이트 == 1000메가바이트
- 1테라바이트 == 1000기가바이트
2. 워드
- CPU가 한 번에 처리할 수 있는 정보의 크기 단위
- 각 CPU마다 달라진다
- 하프 워드는 워드의 절반 크기, 풀 워드는 워드 크기, 더블 워드는 워드의 두 배 크기를 의미함

3. 이진법: 0과 1로 숫자 표현하기
- 0과 1로 수를 표현하는 방법
- 숫자가 1을 넘어가는 시점에 자리올림
- 우리가 일상적으로 사용하는 진법은 숫자가 9를 넘어갈 때 자리올림하는 십진법(Decimal)
- 0과 1로 음수를 표현할 때에는 2의 보수값을 사용한다
- 모든 0과 1을 뒤집고 1을 더한 값이 2의 보수값, 즉 음수값이 된다

4. 16진법
- 이진법으로는 숫자의 길이가 너무 길어진다(ex 십진법의 32 == 이진수 100000)
- 그래서 컴퓨터의 데이터를 표현할 때 16진법도 많이 사용
- 2진법에서 16진법으로의 변환은 4개씩 나누어 16진법으로 변환해서 합치면 되고, 그 반대는
1개씩 나누어 2진법으로 변환하여 합치면 된다

5강
 0과 1로 문자를 표현하는 방법
문자 집합과 인코딩
- 문자 집합(Character Set)이란 컴퓨터가 이해할 수 있는 문자의 모음
- 인코딩(Encoding)이란 코드화하는 과정을 말하며, 문자를 0과 1로 이루어진 문자 코드로
변환하는 과정을 말한다
- 디코딩(Decoding)이란 코드를 해석하는 과정을 말하며, 0과 1로 표현된 문자 코드를 문자로
변환하는 과정을 말한다

아스키 코드
- 초창기 문자 집합 중 하나
- 알파벳, 아라비아 숫자, 일부 특수 문자 및 제어 문자
- 7비트로 하나의 문자를 포현하며, 8비트중 1비트는 오류 검출을 위해 사용되는 패리티 비트(
Parity bit)로 사용된다

한글의 인코딩
- 한글의 인코딩에는 단어하나를 만든후 코드를 부여하는 완성형 인코딩과 각 모음 혹은 자음에
코드를 부여하여 합치는 조합형 인코딩이 존재한다
- 모든 한글을 표현하기에는 제한이 존재한다

유니코드 문자 집합과 UTF-8
- 통일된 문자 집합
- 한글, 영어, 화살표와 같은 특수 문자, 심지어 이모티콘까지 가능함
- 현재 문자 표현에 있어 매우 중요한 위치
- 유니코드의 인코딩 방식에는 UTF-8뿐만 아니라 UTF-16, UTF-32 등이 존재한다

UTF-8 인코딩
- UTF(Unicode Transformation Format) == 유니코드 인코딩 방법
- 가변 길이 인코딩이며 그 결과가 1 ~ 4바이트이다
- 인코딩 결과가 몇 바이트가 될지는 유니코드에 부여된 값에 따라 다르다

6강
 소스코드와 명령어
고급 언어와 저급 언어
- 고급 언어에는 사용자가 사용하는 c++, c, java 등이 있다
- 저급 언어에는 0과 1로 이루어진 기계어, 기계어를 읽기 편한 언어로 번역한 어셈블리어가 있다

컴파일 언어와 인터프리트 언어
- 컴파일 언어는 잘 알고 있는 그것이다. 인클루드된 헤더로 링크되며, 소스 코드 전체를 읽어가며
오류 검출 등을 하여 컴파일러가 목적 코드로 변환한다
- 인터프리트 언어는 한줄씩 실행하기 때문에 소스 코드 전체가 저급 언어로 변환되기를 기다릴 필요가 없다
- 컴파일 언어는 하나라도 오류가 있으면 실행 자체가 안되지만, 인터프리트 언어는 오류가 존재할 시
오류 이전까지는 올바르게 실행됨

7강
 C언어의 컴파일 과정
 1. 전처리기
 - 본격적으로 컴파일하기 전에 처리할 작업들
 - 외부에 선언된 다양한 소스 코드, 라이브러리 포함(ex. #include) 주의할점은 선언이 들어있는
 헤더파일들만 복사하여 옮긴다
 - 프로그래밍의 편의를 위해 작성된 매크로 변환(ex. #define)
 - 컴파일할 영역 명시(ex. #if, #ifdef)
 - 인클루드된 헤더 파일을 소스 코드로 복사하여 붙여넣는다
 - 말 그대로 붙여넣기만 하기 때문에 코드가 추가될 뿐 변환되는 것은 없다
 2. 컴파일러
 - 전처리가 완료 되어도 여전히 소스 코드
 - 전처리 완료된 소스 코드를 저급 언어(어셈블리 언어)로 변환
 3. 어셈블러
 - 어셈블리어를 기계어로 변환
 - 목적 코드(Object Code)를 포함하는 목적 파일이 됨
 - 목적 파일과 실행 파일은 둘 다 기계어로 이루어진 파일이긴 하지만 다름
 - 목적 파일이 링커의 의해 링킹을 거친 후에야 실행 파일이 된다
 4. 링커
 - 인클루드 된 헤더파일에 존재하는 함수나 전역 변수를 호출할시 전처리시에 헤더만 포함시켰기 때문에 
 선언만 있고 구현이 없는 상황이기에 동적 링크(구현문이 있는 위치를 남겨둠) 혹은 정적 링크(실제 구현문을
 복사하여 옮김)로 대체하여 실행 파일을 만든다