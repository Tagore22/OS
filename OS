1강
 - 컴퓨터를 단순히 미지의 대상에서 분석의 대상으로 인식하기 위해 컴퓨터 구조와 OS에 대해 알아야 한다
 - 문법에 맞는 소스 코드를 컴퓨터에 입력만 하는 개발자를 넘어 컴퓨터를 내려다보며 문제를 해결할 수 있는
 개발자를 지향해야 한다
 - 컴퓨터의 성능, 용량, 비용에 대해 알아야 한다

2강
 컴퓨터 구조의 큰 그림

컴퓨터가 이해하는 두 가지 정보
1. 데이터
- 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
- 컴퓨터와 주고 받는 내부에 저장된 정보를 데이터라 통칭함
- 0과 1로 숫자와 문자를 표현하는 방법
2. 명령어
- 컴퓨터는 결국 명령어를 처리하는 기계
- 컴퓨터를 실질적으로 움직이는 정보
- 데이터는 명령어를 위한 일종의 재료
- 명령어의 생김새와 동작 방식

컴퓨터의 4가지 핵심 부품
1. CPU
- 산술논리연산장치(계산기)인 ALU, CPU내의 저장을 위한 레지스터, 제어 신호를 내보내고 명령어를 해석하는
제어장치 3개로 구분할 수 있다
- 메모리에 저장된 값을 읽어 들이고, 해석하고, 실행하는 장치다
2. 메모리
- 현재 실행되는 프로그램(프로세스)의 명령어와 데이터를 저장하는 부품(RAM)
- 휘발성의 RAM과 비휘발성의 ROM으로 나뉘며 RAM에는 하드디스크의 저장된 데이터를 CPU에서 사용하기 위해
저장하고 ROM에는 부팅시스템 같은 읽기만 하는 데이터가 미리 저장되어 있다
- 프로그램이 실행되기 위해서는 메모리에 저장되어 있어야 한다
- 메모리는 실행되는 프로그램의 명령어와 데이터를 저장한다
- 메모리에 저장된 값의 위치는 주소로 알 수 있다
3. 보조기억장치
- 휘발성 있는 RAM을 대비하여 비휘발성의 보조기억장치가 존재한다
- 하드디스크, SSD 등이 해당함
4. 입출력장치
- 키보드, 모니터, 프린트 등이 해당한다
5. 메인보드
- 메인보드에 연결된 부품은 버스를 통해 정보를 주고 받음
- 버스는 컴퓨터의 부품끼리 정보를 주고 받는 일종의 통로
- 다양한 종류의 버스가 있으나 핵심 부품을 연결하는 버스는 시스템 버스

시스템 버스의 내부 구성
1. 주소 버스
- 주소를 주고 받는 통로
2. 데이터 버스
- 명령어와 데이터를 주고 받는 버스
3. 제어 버스
- 제어 신호를 주고 받는 버스
- 읽기와 쓰기 모두 3가지 버스를 전부 사용한다
- 읽을때에는 읽는 신호, 몇번지 값을 읽는지에 대해 제어 버스와 주소 버스를 사용하고 해당 데이터를 읽어들일때
데이터 버스를 사용한다
- 쓸때에는 쓰는 신호, 몇번지에 쓰는지, 쓸값을 이동시키기 위해 제어 버스, 주소 버스, 데이터 버스를 사용한다

3강
 컴퓨터의 4가지 핵심 부품 직접 보기로 대체

4강
 0과 1로 숫자를 표현하는 방법
정보 단위
1. 비트
- 비트란 0과 1을 표현하는 가장 작은 정보 단위를 뜻한다
- n비트로 2의 n제곱가지의 정보 표현 가능
- 프로그램은 많은 비트로 이루어져 있음
- 다만 평소에 800만 비트라고 표현하지 않고 바이트, 킬로바이트, 메가바이트, 기가바이트, 테라바이트 등으로
표현함
- 1바이트 == 8비트
- 1킬로바이트 == 1000바이트
- 1메가바이트 == 1000킬로바이트
- 1기가바이트 == 1000메가바이트
- 1테라바이트 == 1000기가바이트
2. 워드
- CPU가 한 번에 처리할 수 있는 정보의 크기 단위
- 각 CPU마다 달라진다
- 하프 워드는 워드의 절반 크기, 풀 워드는 워드 크기, 더블 워드는 워드의 두 배 크기를 의미함

3. 이진법: 0과 1로 숫자 표현하기
- 0과 1로 수를 표현하는 방법
- 숫자가 1을 넘어가는 시점에 자리올림
- 우리가 일상적으로 사용하는 진법은 숫자가 9를 넘어갈 때 자리올림하는 십진법(Decimal)
- 0과 1로 음수를 표현할 때에는 2의 보수값을 사용한다
- 모든 0과 1을 뒤집고 1을 더한 값이 2의 보수값, 즉 음수값이 된다

4. 16진법
- 이진법으로는 숫자의 길이가 너무 길어진다(ex 십진법의 32 == 이진수 100000)
- 그래서 컴퓨터의 데이터를 표현할 때 16진법도 많이 사용
- 2진법에서 16진법으로의 변환은 4개씩 나누어 16진법으로 변환해서 합치면 되고, 그 반대는
1개씩 나누어 2진법으로 변환하여 합치면 된다

5강
 0과 1로 문자를 표현하는 방법
문자 집합과 인코딩
- 문자 집합(Character Set)이란 컴퓨터가 이해할 수 있는 문자의 모음
- 인코딩(Encoding)이란 코드화하는 과정을 말하며, 문자를 0과 1로 이루어진 문자 코드로
변환하는 과정을 말한다
- 디코딩(Decoding)이란 코드를 해석하는 과정을 말하며, 0과 1로 표현된 문자 코드를 문자로
변환하는 과정을 말한다

아스키 코드
- 초창기 문자 집합 중 하나
- 알파벳, 아라비아 숫자, 일부 특수 문자 및 제어 문자
- 7비트로 하나의 문자를 포현하며, 8비트중 1비트는 오류 검출을 위해 사용되는 패리티 비트(
Parity bit)로 사용된다

한글의 인코딩
- 한글의 인코딩에는 단어하나를 만든후 코드를 부여하는 완성형 인코딩과 각 모음 혹은 자음에
코드를 부여하여 합치는 조합형 인코딩이 존재한다
- 모든 한글을 표현하기에는 제한이 존재한다

유니코드 문자 집합과 UTF-8
- 통일된 문자 집합
- 한글, 영어, 화살표와 같은 특수 문자, 심지어 이모티콘까지 가능함
- 현재 문자 표현에 있어 매우 중요한 위치
- 유니코드의 인코딩 방식에는 UTF-8뿐만 아니라 UTF-16, UTF-32 등이 존재한다

UTF-8 인코딩
- UTF(Unicode Transformation Format) == 유니코드 인코딩 방법
- 가변 길이 인코딩이며 그 결과가 1 ~ 4바이트이다
- 인코딩 결과가 몇 바이트가 될지는 유니코드에 부여된 값에 따라 다르다

6강
 소스코드와 명령어
고급 언어와 저급 언어
- 고급 언어에는 사용자가 사용하는 c++, c, java 등이 있다
- 저급 언어에는 0과 1로 이루어진 기계어, 기계어를 읽기 편한 언어로 번역한 어셈블리어가 있다

컴파일 언어와 인터프리트 언어
- 컴파일 언어는 잘 알고 있는 그것이다. 인클루드된 헤더로 링크되며, 소스 코드 전체를 읽어가며
오류 검출 등을 하여 컴파일러가 목적 코드로 변환한다
- 인터프리트 언어는 한줄씩 실행하기 때문에 소스 코드 전체가 저급 언어로 변환되기를 기다릴 필요가 없다
- 컴파일 언어는 하나라도 오류가 있으면 실행 자체가 안되지만, 인터프리트 언어는 오류가 존재할 시
오류 이전까지는 올바르게 실행됨

7강
 C언어의 컴파일 과정
 1. 전처리기
 - 본격적으로 컴파일하기 전에 처리할 작업들
 - 외부에 선언된 다양한 소스 코드, 라이브러리 포함(ex. #include) 주의할점은 선언이 들어있는
 헤더파일들만 복사하여 옮긴다
 - 프로그래밍의 편의를 위해 작성된 매크로 변환(ex. #define)
 - 컴파일할 영역 명시(ex. #if, #ifdef)
 - 인클루드된 헤더 파일을 소스 코드로 복사하여 붙여넣는다
 - 말 그대로 붙여넣기만 하기 때문에 코드가 추가될 뿐 변환되는 것은 없다
 2. 컴파일러
 - 전처리가 완료 되어도 여전히 소스 코드
 - 전처리 완료된 소스 코드를 저급 언어(어셈블리 언어)로 변환
 3. 어셈블러
 - 어셈블리어를 기계어로 변환
 - 목적 코드(Object Code)를 포함하는 목적 파일이 됨
 - 목적 파일과 실행 파일은 둘 다 기계어로 이루어진 파일이긴 하지만 다름
 - 목적 파일이 링커의 의해 링킹을 거친 후에야 실행 파일이 된다
 4. 링커
 - 인클루드 된 헤더파일에 존재하는 함수나 전역 변수를 호출할시 전처리시에 헤더만 포함시켰기 때문에 
 선언만 있고 구현이 없는 상황이기에 동적 링크(구현문이 있는 위치를 남겨둠) 혹은 정적 링크(실제 구현문을
 복사하여 옮김)로 대체하여 실행 파일을 만든다

8강
 명령어의 구조와 주소 지정 방식

명령어의 구조
- 무엇을 대상으로, 무엇을 수행해라의 형태
- 연산 코드(수행할 연산)와 오퍼랜드(연산에 사용될 데이터 혹은 데이터가 저장된 위치)로 구성되어 있다
- 기계어, 어셈블리어도 명령어다
- 오퍼랜드는 상황에 따라 0개 이상이다
- 데이터보다 위치의 주소를 더 많이 저장하게 되는데 데이터보다 주소의 크기가 더 적기 때문에
더 많은 양을 담을 수 있기 때문이다

명령어 주소 지정 방식
- 연산에 사용할 데이터가 저장된 위치를 찾는 방법
- 유효 주소를 찾는 방법

다양한 명령어 주소 지정 방식들
1. 즉시 주소 지정 방식
- 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시
- 가장 간단한 형태의 주소 지정 방식
- 연산에 사용할 데이터의 최대 크기가 작아질 수 있지만, 빠르다
2. 직접 주소 지정 방식
- 오퍼랜드 필드에 유효 주소를 직접적으로 명시
- 유효 주소를 표현할 수 있는 크기가 연산 코드만큼 줄어듬
3. 간접 주소 지정 방식
- 오퍼랜드 필드에 유효 주소의 주소를 명시
- 앞선 주소 지정 방식들에 비해 속도가 제일 느림
- 직접 주소 지정 방식에서는 데이터가 존재하는 고유한 주소값을 사용하기 때문에 모든 명령어에
각기 다른 주소값이 포함되지만, 간접 주소 지정 방식에서는 하나의 주소값에 여러개의 주소값을
담을 수 있기에 매번 명령어마다 주소값을 필요로 하지 않는다
결과적으로 메모리는 3번이 제일 유리하고, 속도면에서는 1번이 제일 유리하다
4. 레지스터 주소 지정 방식
- 연산에 사용할 데이터가 저장된 레지스터 명시
- 메모리에 접근하는 속도보다 레지스터에 접근하는 것이 빠름
5. 레지스터 간접 주소 지정 방식
- 연산에 사용할 데이터를 메모리에 저장
- 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
- 간접 주소 지정 방식과 비슷하게 하나에 레지스터를 통해 여러개의 주소에 접근할 수 있기에
메모리를 적게 차지한다

9강
 CPU의 내부 구성 - ALU와 제어장치

플래그 레지스터
- CPU 내부에 존재하는 특수한 레지스터로써, 연산 결과의 부호, 제로 여부, 올림 및 내림, 오버플로우,
인터럽트 가능 여부, 커널 모드 혹은 사용자 모드인지에 대해 저장한다

제어 장치
- 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위를 클럭이라고 한다
- 제어 장치는 플래그 레지스터, 명령어 레지스터로부터 데이터를 저장하고, ALU, 메모리, 레지스터, 입출력장치로
신호를 전달한다

10강
 CPU의 내부 구성 - 레지스터

레지스터
- CPU 내부의 작은 임시저장장치이며 프로그램 속 명령어와 데이터는 실행 전후로 
레지스터에 저장된다
- CPU 내부에는 다양한 레지스터가 존재하며 각기 다른 역할을 가진다
1. 프로그램 카운터
- 메모리에서 가져올 명령어의 주소
2. 명령어 레지스터
- 해석할 명령어. 이것을 제어 장치가 해석함
3. 메모리 주소 레지스터
- 주소 버스를 통해 읽어야하는 메모리의 주소를 저장
4. 메모리 버퍼 레지스터
- 데이터 버스를 통해 읽어들이는 실제값(데이터 혹은 명령어)
5. 플래그 레지스터
- 연산 결과 또는 CPU 상태에 대한 부가적인 정보
6. 범용 레지스터
- 다양하고 일반적인 상황에서 자유롭게 사용. 주소만 담을 수 있는 메모리 주소 레지스터, 명령어 혹은 
데이터만 담을 수 있는 메모리 버퍼 레지스터와는 다르게 모든 내용의 데이터를 담을 수 있다
7. 스택 포인터
- 특별한 주소 지정에 사용
- 스택과 스택 포인터를 이용하여 스택 주소 지정 방식을 사용하는데 이때 스택 포인터는
스택의 꼭대기를 가르키며 어디까지 차있는지 표시하게 된다
8. 베이스 레지스터
- 변위 주소 지정 방식에 사용
1. 상대 주소 지정 방식
- 오퍼랜드 필드의 값(변위)과 프로그램 카운터의 값을 더하여 유효 주소를 얻음
2. 베이스 레지스터 주소 지정 방식
- 오퍼랜드 필드의 값(변위)과 베이스 레지스터의 값을 더하여 유효 주소를 얻음

11강
 명령어 사이클과 인터럽트

명령어 사이클
- 프로그램 속 명령어들은 일정한 주기가 반복되며 실행되는데 이 주기를 명령어 사이클이라고 한다
인터럽트
- CPU가 꼭 주목해야 할 때, CPU가 얼른 처리해야 할 다른 작업이 생겼을 때 발생
- 현재 진행중인 일을 멈추고, 다른 일을 먼저 처리한다
1. 동기 인터럽트(예외)
- CPU가 예기치 못한 상황을 접했을 때 발생
2. 비동기 인터럽트(하드웨어 인터럽트)
- 주로 입출력장치에 의해 발생
- 입, 출력 완료시에 발생
- 입출력 작업 도중에도 주기적으로 완료여부를 확인하지 않고 효율적으로 명령어를 처리하기 위해서 사용
- 인터럽트의 처리 순서는 다음과 같다
1. 입출력 장치는 CPU에 인터럽트 요청 신호를 보낸다
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 확인
4. 인터럽트를 받아들일 수 있다면 CPU는 현재까지의 작업을 백업한다
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다
6. 인터럽트 서비스 루틴 실행이 끝나면 4에서 백업해 둔 작업을 복구하여 실행을 재개한다

12강
 빠른 CPU를 위한 설계 기법

클럭 속도
- 헤르츠(Hz) 단위로 측정
- 헤르츠(Hz)란 1초에 클럭이 반복되는 횟수
- 1초에 1번 클럭이 진행되면 1Hz
- 1초에 클럭이 100번 진행되면 100Hz
- 단순히 클럭속도만 늘린다면 속도는 올라가겠으나 발열이 심해진다

코어
- 현대적인 관점에서 CPU라는 용어를 재해석 해야 함
- 명령어를 실행하는 부품만이 아니다
- 전통적으로 명령어를 실행하는 부품은 원칙적으로 하나만 존재
- 하지만 오늘날 CPU에는 명령어를 실행하는 부품이 여러개 존재 가능
- 명령어를 실행하는 부품을 코어라는 용어로 사용
- 단순히 코어가 늘어난다고 그에 비례해서 속도가 늘어나진 않는다

스레드
- 실행 흐름의 단위
- 스레드에는 하드웨어적 스레드와 소프트웨어적 스레드로 나눌 수 있다
1. 하드웨어 스레드
- 하나의 코어가 동시에 처리하는 명령어 단위
- CPU안의 코어 자체에서 여러개의 스레드를 처리하게끔 설계되어 있다
- 논리 프로세서라고도 부른다
- 하드웨어적 멀티스레드에서 가장 중요한것은 명령어를 입력받을 여러개의 레지스터의 유무다
소프트웨어의 시분할 스레드처럼 정말 빠른속도로 멀티스레드처럼 보이는 것이 아닌
진짜로 여러개의 스레드를 동시에 처리하기 위해 명령어를 담을 여러개의 레지스터가 필요하기 때문
2. 소프트웨어 스레드
- 하나의 프로그램에서 독립적으로 실행하는 단위
- 프로그래머가 구현해야함
- 하드웨어적 멀티스레드처럼 정말 여러개의 스레드를 병렬 실행하는게 아닌 빠른 속도로
하나의 스레드가 여러개의 작업을 처리하는 시분할 방식